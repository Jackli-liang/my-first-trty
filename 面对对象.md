# python面对对象

## 面对对象的简介：

- **类**：用来描述具有相同的属性和方法的对象的集合。它定义了该集合中每个对象所共有的属性和方法，对象是类的实例。
- **对象**：通过类定义的数据结构实例。对象包括两个数据成员（类变量和实例变量）和方法。
- **方法**：类中定义的函数。
- **类变量**：类变量在整个实例化的对象中是公用的。类变量定义在类中且在函数体之外。类变量通常不作为实例变量使用。
- **数据成员**：类变量或者实例变量用于处理类及其实例对象的相关的数据。
- **方法重写**：如果从父类继承的方法不能满足子类的需求，可以对其进行改写，这个过程叫方法的重写。
- **局部变量**：定义在方法中的变量，只作用于当前实例的类。
- **实例变量**：在类的声明中，属性是用变量来表示的。这种变量就称为实例变量，是在类声明的内部但是在类的其他成员方法之外声明的。
- **继承**：即一个派生类继承基类的字段和方法。继承也允许把一个派生类的对象作为一个基类对象对待。例如：一个Dog类型的对象派生自Animal类，这是模拟一个（is-a）关系。
- **实例化**：创建一个类的实例，类的具体对象。

### 类定义：

class Classname:

### 类对象：

```中文
class MyClass:
    """一个简单的类实例"""
    i = 12345
    def f(self):
        return 'hello world'
 
# 实例化类
x = MyClass()
 
# 访问类的属性和方法
print("MyClass 类的属性 i 为：", x.i)
print("MyClass 类的方法 f 输出为：", x.f())


类有一个名为 __init__() 的特殊方法（构造方法），该方法在类实例化时会自动调用。



```

```中文
class Complex:
    def __init__(self, realpart, imagpart):
        self.r = realpart
        self.i = imagpart
x = Complex(3.0, -4.5)
print(x.r, x.i)   # 输出结果：3.0 -4.5



```

### 类的方法：

在类的内部，使用 def 关键字来定义一个方法，与一般函数定义不同，类方法必须包含参数 self ，且为第一个参数，self 代表的是类的实例。

 

[https://www.runoob.com/python3/python3-class.html]: 见此链接中“类的方法”，“单继承”，“多继承”

### 方法的重写：

super（“子类，子类实例”）函数是用于调用父类的一个方法

### 类属性与方法：

- 类的私有属性：**__private_attrs**__：两个下划线开头，声明该属性为私有，不能在类的外部被使用或直接访问。在类内部的方法中使用时 **self.__private_attrs**。
- 类的方法：在类的内部，使用 def 关键字来定义一个方法，与一般函数定义不同，类方法必须包含参数 **self**，且为第一个参数，**self** 代表的是类的实例。self 的名字并不是规定死的，也可以使用 **this**，但是最好还是按照约定是用 **self**。
- 类的私有方法：**__private_method**：两个下划线开头，声明该方法为私有方法，只能在类的内部调用 ，不能在类的外部调用。**self.__private_methods**。

@  实例不能访问私有变量



### 封装：（ATM取款机）

- 将类的某些信息隐藏在类的内部，不允许外部程序直接访问。
- 通过该类提供的方法来实现对隐藏信息的操作和访问。
- **隐藏**对象的信息。
- **留出**访问的接口。

特点 1.只能通过规定的方法访问数据。

​         2.隐藏类的实例细节，方便修改和实现。

### 继承：

- 一种类与类之类的关系（A is a B）
- 使用已存在的类的定义作为基础建立新类，父类被称为基类，子类被称为派生类。
- 新类的定义可以增加新的数据或新的功能，也可用父类的功能，但不能选择性的继承父类。只能全部继承父类的属性
- 

 特点 1.利于代码的复用。

​         2.缩短开发周期。

### 多态：

允许不同类的对象对同一消息做出不同的响应。

- 需要满足继承关系
- 需要方法的重写

### 类的高级特性：

@ property    @slots 

### 类的静态方法与实例方法：

staticmethod 与 classmethod 对应的函数都不需要实例化

静态方法@staticmethod       

 类方法@classmethod   传第一个的参数表示自身的  cls  参数

### 常用的高阶函数：

- lambda函数（匿名函数）:它是一种表达式，不用 def  结构
- filter函数：返回一个列表，其中包含对其执行函数时结果为真的所有元素filter（func参数，seq序列）过滤器。(返回迭代器的对象)
- map函数：创建一个列表，其中包含对指定序列包含的项执行指定函数返回的值。map（function，sequence）。(对指定序列做映射)
- reduce函数：对参数序列进行累积

### 装饰器：

- 拓展其他函数功能的函数
- 并且返回的也是函数（**包裹函数**）
- 在不更改原函数代码的前提下给函数增加新的功能
- **@  +  函数名**（参数 ）

### 带参数的装饰器（wraps）：

返回一个包裹函数的函数。

### 类的装饰器：

类也可以用来构建装饰器，使用继承的方式。

类的装饰器主要依靠类的__call__方法。

*args  提供多个参数的传递,**kwargs  参数当中定义了关键字参数。

### 迭代器：

- 迭代是python最强大的功能之一，是访问集合元素的一种方式。
- 迭代器是一种可以记住遍历的位置的对象。
- 迭代器对象从集合的第一个元素开始访问，直到所有的元素被访问结束，迭代器只能往前不会后退。
- 迭代器的基本方法：iter（）创建迭代器对象和next（）输出迭代器对象。
- 字符串，列表和元组对象都可以用于创建迭代器。

把类作为一个迭代器使用需要在类中实现两个方法：__iter__() 与 __next__()

### 生成器:

使用yield的函数被称为生成器，它是一个返回迭代器的函数，只能用于迭代操作。

调用生成器运行的过程中，每次遇到 yield 时函数会暂停并保存当前所有的运行信息，返回 yield 的值, 并在下一次执行 next() 方法时从当前位置继续运行。

## 正则表达式：

定义：它是一些由字符和特殊符号组成的字符串 

功能： 按照某种模式匹配一系列的有相似特征的字符串 

#### 匹配范围：

- ​     .       匹配任意字符

- ​     *       匹配0个或多个的表达式
- ​    +        匹配1个或多个的表达式
- ​    ？      匹配0个或1个由前面的正则表达式定义的片段
-   {N}       匹配指定的次数
-  {M,N}    匹配M-N次，最大化优先

#### 匹配同类型：

-    \d    匹配数字（整数）
-    \w   匹配数字和字母（不区分大小写），下划线.相当于[a-zA-Z0-9_]
-    \s    匹配任何空格字符（空格，\n  .........）

#### 边界匹配：

- ^ (指定内容)   匹配以  ^()     开头
- (指定内容)$    匹配以   ()$   结尾

#### 匹配特殊字符：

- 需要用  ”\“   进行转义

​       例如：www.baidu.com     \ .com$   这里转义之后把 .  当作一个字符，而不是匹配任意字符。与class class_  有些类似 已经存在的关键字需要转义

- ^\^  表示匹配以   ^开头

- \/\/   表示匹配  //    两个\ \  表示转义

#### 匹配指定选项：

- 使用  []   指定匹配的集合

    [abc]{2}    匹配集合[abc]中的任意元素的长度为2

- 使用    [^]   指定不要匹配的内容

​           【^abc】{2}     匹配排除[abc]中的任意元素的长度为2的其他内容

#### 分组：

- 重复一个字符串时
- 使用（）进行分组，使用（?P<word>\w+）指定组名     groupdict()   返回分组名
- 从左向右，以分组的左括号为标志，第一个出现分组的组号为1，第二个为2，以此类推

1   使用（）对匹配的内容进行分组

​        例如：   (\d{1，3} \.){3}\d{1,3}                 192.168.60.14

2   使用  \1、\2   反向引用





#### 贪婪模式与非贪婪模式：

##### 贪婪匹配：

在整个表达式匹配成功的前提下，尽可能多的匹配

##### 非贪婪匹配：

在整个表达式匹配成功的前提下，以最少的匹配字符

默认匹配是贪婪模式



#### 正则表达式当中的函数：

- **re.match函数：**

​         尝试从字符串的起始位置匹配一个模式，如果不是起始位置匹配成功的话，match（）就返回nione

​       re.match(pattern 匹配的正则表达式,string  要匹配的字符串 ,flags=0 标志位)

```英文

```

```
import re
print(re.match('www', 'www.runoob.com').span())  # 在起始位置匹配
print(re.match('com', 'www.runoob.com'))         # 不在起始位置匹配

结果为：
      （0，3）
        None
```

- **re.search函数:**

​       扫描整个字符串并返回第一个成功的匹配

​       re.search(pattern 匹配的正则表达式,string  要匹配的字符串 ,flags=0 标志位)



```
import re
print(re.search('www', 'www.runoob.com').span())  # 在起始位置匹配
print(re.search('com', 'www.runoob.com').span())         # 不在起始位置匹配

结果为：
    （0，3）
    （11，14）
```

##### 检索和替换：

re.sub 用于替换字符串中的匹配项

re.sub(pattern,repal,string,count=0,flags-=0)

- pattern : 正则中的模式字符串。
- repl : 替换的字符串，也可为一个**函数。**
- string : 要被查找替换的原始字符串。
- count : 模式匹配后替换的最大次数，默认 0 表示替换所有的匹配。
- flags : 编译时用的匹配模式，数字形式

前三个为必选参数，后两个为可选参数。

实例代码：

```中文
import re
phone = "2004-959-559 # 这是一个电话号码"

# 删除注释

num = re.sub(r'#.*$', "", phone)
print ("电话号码 : ", num)

# 移除非数字的内容

num = re.sub(r'\D', "", phone)
print ("电话号码 : ", num)
     打印结果：
     电话号码 :  2004-959-559 
     电话号码 :  2004959559
     

```

**compile 函数：**

​      用于编译正则表达式，生成一个正则表达式对象，供match（）和search（）使用

​       re.compile(pattern[,flags])

**findall  函数：**

​      re.findall(string待匹配的字符串,pos起始位置默认为0[, endpos 结束位置])

**re.finditer 函数：**

​     在字符串中找到正则表达式所匹配的所有子串，并作为一个迭代器返回

​      re.finditer(pattern, string,flags=0)

**re.split 函数：**

​      按照能够匹配的子串将字符串分割后返回列表

​      re.split(pattern, string[, maxsplit=0  分割次数默认为0 ,flags=o])

​     





 







 

  







